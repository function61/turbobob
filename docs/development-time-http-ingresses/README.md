Development-time HTTP ingresses
===============================

Contents:

- [What you'll get](#what-you-ll-get)
- [Supported loadbalancers](#supported-loadbalancers)
- [You need a wildcard DNS entry](#you-need-a-wildcard-dns-entry)
- [How do I use it](#how-do-i-use-it)
- [Alternative approach](#alternative-approach)


What you'll get
---------------

If you have a project called `foobar`, Bob will configure your loadbalancer automatically
so you can reach the app at `https://foobar.dev.example.com/`.


Supported loadbalancers
-----------------------

This feature works by Bob adding Docker container metadata labels in Traefik-compliant format.

These metadata labels are picked up by the loadbalancer and thus it automatically starts
forwarding traffic to the container.

Supported loadbalancers:

- [Edgerouter](https://github.com/function61/edgerouter) (supports Traefik-compliant labels)
- [Traefik](https://traefik.io/)

The autogenerated labels look like this:

- `traefik.frontend.rule=Host:foobar.dev.example.com`
- `traefik.port=80`


You need a wildcard DNS entry
-----------------------------

You can:

- Set up wildcard subdomain for your domain or
- You can use the public [xip.io](http://xip.io/) (no registration or set-up).
  * If your loadbalancer is reachable via IP `127.0.0.1`, use `127.0.0.1.xip.io` as the domain.
    Your app will then be reachable at `foobar.127.0.0.1.xip.io`.
  * If your loadbalancer is on another IP, just change it from the URL.


How do I use it
---------------

Now that you decided on the wildcard DNS entry, you need to configure that in Turbobob
user config (this file applies to all the projects that you develop).

In our example case the wildcard entry is `*.dev.example.com`.

Write file `turbobob-userconfig.json` in your homedir (`/home/foo` on Linux, `C:\Users\foo` on Windows etc.):

```json
{
	"dev_ingress_settings": {
		"domain": "dev.example.com"
	}
}
```

Now let's say you have a project with this `turbobob.json` (unrelated lines removed):

```json
{
	"project_name": "joonas.fi-blog",
	"builders": [
		{
			"name": "default",
			"uses": "docker://joonas/jekyll-builder:0.1.0",
			"mount_destination": "/project",
			"workdir": "/project",
			"commands": {
				"build": ["bin/build.sh"],
				"dev": ["bash"]
			},
			"dev_http_ingress": "80",
			"dev_pro_tips": ["For preview run $ bin/preview.sh"]
		}
	]
}
```

The `dev_http_ingress` is the magic here, and it specifies the container port to forward
traffic to.

Now when you start dev, you'll get pro-tips like these:

```console
Pro-tip: Dev ingress: https://joonas-fi-blog.dev.example.com/
Pro-tip: For preview run $ bin/preview.sh
$ 
```

Technically, Bob uses this formula for hostnames: `<project name>-<builder name>.<domain>`.
This is to support same project name having multiple containers that use HTTP. But as a
special case, if your builder name is `default`, that is left out.


Alternative approach
--------------------

If you don't like this, you can also just map ports to be visible from your host.

I find HTTP ingresses useful because then I don't have to remember which port a given
project is on, and be in charge of figuring out unique ports for each project.
